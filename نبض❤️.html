<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Corazón Mágico de Amor</title>
<link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: 'Great Vibes', cursive;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
  }
  canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
  }
  #instructions {
    position: absolute;
    bottom: 20px;
    width: 100%;
    text-align: center;
    color: rgba(255, 255, 255, 0.7);
    font-size: 1.2em;
    z-index: 10;
    pointer-events: none;
  }
</style>
</head>
<body>
<div id="instructions">Cada latido libera mensajes de amor</div>

<script>
// Configuración de partículas
const canvas = document.createElement('canvas');
document.body.appendChild(canvas);
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const colors = ['#ff6b6b', '#ffdd59', '#ff9ff3', '#48dbfb', '#1dd1a1', '#f368e0'];
let particles = [];
let smallHearts = [];
let phrases = ["Te amo 😘", "Eres mi todo ❤️", "Siempre tú y yo 💕", "Amor eterno 💖", "Contigo hasta el fin 🌹", 
               "Mi corazón es tuyo 💘", "Eres mi sueño 💫", "Juntos por siempre 🌟", "Mi amor por ti crece 💞"];

// Estrellas fijas y fugaces
let stars = [];
let shootingStars = [];

function random(min, max) {
  return Math.random() * (max - min) + min;
}

function drawHeart(x, y, size, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  const topCurveHeight = size * 0.3;
  ctx.moveTo(x, y + topCurveHeight);
  // Curva izquierda superior
  ctx.bezierCurveTo(
    x, y, 
    x - size/2, y, 
    x - size/2, y + size/3
  );
  // Curva izquierda inferior
  ctx.bezierCurveTo(
    x - size/2, y + size/2, 
    x, y + size/1.5, 
    x, y + size
  );
  // Curva derecha inferior
  ctx.bezierCurveTo(
    x, y + size/1.5, 
    x + size/2, y + size/2, 
    x + size/2, y + size/3
  );
  // Curva derecha superior
  ctx.bezierCurveTo(
    x + size/2, y, 
    x, y, 
    x, y + topCurveHeight
  );
  ctx.fill();
}

// Crear estrellas fijas
function createStars() {
  stars = [];
  for(let i = 0; i < 200; i++) {
    stars.push({
      x: random(0, canvas.width),
      y: random(0, canvas.height),
      size: random(0.5, 2),
      brightness: random(0.3, 1),
      twinkleSpeed: random(0.01, 0.05),
      twinkleOffset: random(0, Math.PI * 2)
    });
  }
}

// Dibujar estrellas fijas
function drawStars() {
  stars.forEach(star => {
    const brightness = star.brightness * (0.7 + 0.3 * Math.sin(star.twinkleOffset));
    ctx.globalAlpha = brightness;
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
    ctx.fill();
    
    // Actualizar el parpadeo
    star.twinkleOffset += star.twinkleSpeed;
  });
  ctx.globalAlpha = 1;
}

// Crear estrellas fugaces
function createShootingStar() {
  const side = Math.floor(random(0, 4));
  let x, y, angle;
  
  switch(side) {
    case 0: // Arriba
      x = random(0, canvas.width);
      y = 0;
      angle = random(Math.PI/4, 3*Math.PI/4);
      break;
    case 1: // Derecha
      x = canvas.width;
      y = random(0, canvas.height/2);
      angle = random(5*Math.PI/4, 7*Math.PI/4);
      break;
    case 2: // Abajo
      x = random(0, canvas.width);
      y = canvas.height;
      angle = random(5*Math.PI/4, 7*Math.PI/4);
      break;
    case 3: // Izquierda
      x = 0;
      y = random(0, canvas.height/2);
      angle = random(Math.PI/4, 3*Math.PI/4);
      break;
  }
  
  shootingStars.push({
    x: x,
    y: y,
    length: random(80, 200),
    speed: random(8, 15),
    angle: angle,
    opacity: 1,
    width: random(1, 3)
  });
}

// Dibujar estrellas fugaces
function drawShootingStars() {
  shootingStars.forEach((star, index) => {
    ctx.strokeStyle = `rgba(255, 255, 255, ${star.opacity})`;
    ctx.lineWidth = star.width;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(star.x, star.y);
    ctx.lineTo(
      star.x - star.length * Math.cos(star.angle),
      star.y + star.length * Math.sin(star.angle)
    );
    ctx.stroke();
    
    // Actualizar posición y opacidad
    star.x += star.speed * Math.cos(star.angle);
    star.y += star.speed * Math.sin(star.angle);
    star.opacity -= 0.015;
    
    // Eliminar si está fuera de la pantalla o muy transparente
    if (star.y > canvas.height * 1.5 || star.x > canvas.width * 1.5 || 
        star.x < -canvas.width * 0.5 || star.opacity <= 0) {
      shootingStars.splice(index, 1);
    }
  });
}

// Latido
let lastBeat = 0;
function heartbeat(timestamp) {
  if (!lastBeat) lastBeat = timestamp;
  
  const elapsed = timestamp - lastBeat;
  const beatDuration = 1200; // 1.2 segundos entre latidos
  
  if (elapsed > beatDuration) {
    // Liberar corazones pequeños y frases en cada latido
    releaseSmallHearts();
    lastBeat = timestamp;
  }
  
  requestAnimationFrame(heartbeat);
}

// Liberar corazones pequeños y frases en cada latido
function releaseSmallHearts() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  // Crear de 2 a 3 frases por latido
  const numPhrases = Math.floor(random(2, 4));
  
  for(let i = 0; i < numPhrases; i++){
    const phrase = phrases[Math.floor(Math.random()*phrases.length)];
    
    // Posición inicial aleatoria alrededor del centro
    const angle = random(0, Math.PI * 2);
    const distance = random(50, 150);
    const startX = centerX + Math.cos(angle) * distance;
    const startY = centerY + Math.sin(angle) * distance;
    
    // Dirección de movimiento (generalmente hacia afuera)
    const moveAngle = angle + random(-0.5, 0.5);
    const speed = random(0.8, 1.5);
    
    smallHearts.push({
      x: startX,
      y: startY,
      vx: Math.cos(moveAngle) * speed,
      vy: Math.sin(moveAngle) * speed,
      text: phrase,
      opacity: 1,
      size: random(22, 32),
      floatOffset: random(0, Math.PI * 2),
      floatSpeed: random(0.01, 0.03),
      life: 1,
      rotation: random(0, Math.PI * 2),
      rotationSpeed: random(-0.02, 0.02)
    });
  }
  
  // Crear corazoncitos de colores que se dispersan
  createColorHearts(centerX, centerY);
}

// Crear corazoncitos de colores que se dispersan (más grandes)
function createColorHearts(centerX, centerY) {
  const numHearts = Math.floor(random(15, 25));
  
  for(let i = 0; i < numHearts; i++){
    const angle = random(0, Math.PI * 2);
    const speed = random(2, 5);
    
    particles.push({
      x: centerX,
      y: centerY,
      size: random(12, 20), // Aumentado de 6-12 a 12-20
      color: colors[Math.floor(Math.random()*colors.length)],
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      opacity: 1,
      life: 1,
      decay: random(0.005, 0.015),
      rotation: random(0, Math.PI * 2),
      rotationSpeed: random(-0.05, 0.05)
    });
  }
}

// Animación principal
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Dibujar cielo negro con estrellas
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  drawStars();
  drawShootingStars();
  
  // Ocasionalmente crear una estrella fugaz
  if (Math.random() < 0.02) {
    createShootingStar();
  }

  // Dibujar corazones pequeños que se dispersan
  particles.forEach((p, index) => {
    // Actualizar posición
    p.x += p.vx;
    p.y += p.vy;
    
    // Reducir velocidad por fricción
    p.vx *= 0.98;
    p.vy *= 0.98;
    
    // Reducir opacidad
    p.opacity -= p.decay;
    p.life = p.opacity;
    
    // Rotación
    p.rotation += p.rotationSpeed;
    
    // Dibujar con opacidad
    ctx.save();
    ctx.globalAlpha = p.opacity;
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rotation);
    
    // Agregar efecto de brillo a los corazones más grandes
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 15;
    
    drawHeart(0, 0, p.size, p.color);
    ctx.restore();
    
    // Eliminar si está invisible
    if (p.opacity <= 0) {
      particles.splice(index, 1);
    }
  });

  // Dibujar frases flotantes
  smallHearts.forEach((h, index) => {
    ctx.save();
    ctx.globalAlpha = h.opacity;
    ctx.fillStyle = "#fff";
    ctx.font = `${h.size}px 'Great Vibes', cursive`;
    ctx.textAlign = 'center';
    
    // Efecto de flotación
    const floatX = Math.sin(h.floatOffset) * 8;
    const floatY = Math.cos(h.floatOffset * 1.3) * 5;
    
    // Rotación suave
    ctx.translate(h.x + floatX, h.y + floatY);
    ctx.rotate(h.rotation);
    
    // Sombra para mejor legibilidad
    ctx.shadowColor = 'rgba(255, 111, 161, 0.7)';
    ctx.shadowBlur = 10;
    ctx.fillText(h.text, 0, 0);
    ctx.restore();
    
    // Actualizar posición y propiedades
    h.x += h.vx;
    h.y += h.vy;
    h.floatOffset += h.floatSpeed;
    h.rotation += h.rotationSpeed;
    h.opacity -= 0.004;  // Desvanecer muy lentamente
    h.life = h.opacity;
    
    // Reducir velocidad gradualmente
    h.vx *= 0.995;
    h.vy *= 0.995;
    
    if(h.opacity <= 0) {
      smallHearts.splice(index, 1);
    }
  });

  requestAnimationFrame(animate);
}

// Inicialización
createStars();
requestAnimationFrame(heartbeat);
animate();

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  createStars();
});

// Efecto de carga inicial
window.addEventListener('load', () => {
  document.body.style.opacity = 0;
  document.body.style.transition = 'opacity 1.5s';
  
  setTimeout(() => {
    document.body.style.opacity = 1;
  }, 500);
});
</script>
</body>
</html>